함수지향 프로그래밍 (명확한 Input Output)

절차지향(간단 명료), 객체지향 프로그래밍(재사용,유지보수)


--------------------------------------------

<함수지향 프로그래밍>
Ex : Java, Kotlin, Python

-----------------------------------------------


<절차지향 프로그래밍>
Ex : C언어

- 코드가 진행되는 순서대로 프로그래밍
- 프로그램 전체가 유기적으로 연결
ex. 통나무를 깎아 의자를 만드는 행위 -> 부품을 추가하거나 수정하는데 어렵다.

*장점*
1. 컴퓨터의 작업 처리방식과 유사하여 상대적으로 빠르다.
-> 사건의 흐름대로 쭉 작성하면 되기에 '작업시간 기준'으로 보자면 상대적으로 빠를수도 있다.
-> 코드를 어떻게 쓰느냐에 따라 차이가 생기는 것이기 때문에 설계의 패러다임에 의해 프로그램의 동작속도가 획기적으로 변한다고 볼 수 없다.

*단점* 
1. 각각의 코드가 유기적으로 연결되어 있어 유지보수가 어렵다. -> 규모가 커지고 복잡도가 올라갈수록 더 난이도가 올라간다.
2. 문제 해결을 위해 일부가 아닌 전체를 수리해야 하기 때문에 유지보수, 디버깅이 힘들다.
3. 코드가 쓰여진 순서대로 진행하기 때문에 순서가 정해져있어 순서가 바뀌거나 결과 또한 달라진다.


-------------------------------------------

[용어 정리]

*Class : : 객체를 설계할 때 필요한 설계도 또는 틀
- 다른 여러 자료형의 변수와 함수를 묶을 수 있는 사용자 정의 자료형
-  Variable -> Array -> Struct -> Class
- 사물의 특성과 행동을 소프트웨어적으로 모델링하여 데이터화 한다.
- C언어의 구조체의 상위호한으로 Class내 함수를 넣어 여러가지 기능을 사용할 수 있다. (구조체 Strcut도 함수를 넣을 수는 있다.)


*Object
: Class의 틀을 참고하여 만들어진 결과물
-> 결과물은 아무런 정보를 가지고 있지 않다. (사용할 수 없는 상태)

*Instance
: 만들어진 Object를 개별적인 정보를 부여하여 만들어진 최종 사용 가능한 상태의 정보 
-> Object를 사용할 수 있는 상태로 만들어주는 것

ex. 변수의 생성 과정을 대입해보면 : int(자료형) = Class -> int Num(변수 선언) = Object -> Num = 10(값 대입) = Instance


----------------------------------------------


<객체지향 프로그래밍>
Ex : C++

1. 추상화(Abstraction) : 대상의 특성을 제외한 공통점을 모아 정보화 한다.
- 공톡적인 특성을 파악해 필요없는 특성을 제거해 공통분모를 하나로 모아 Class를 만들어야 한다.

2. 캡슐화(encapsulation) : 약속된 부분(외부동작)을 제외한 자신의 정보를 숨긴다.(정보은닉) / private(개인) 변수,public(공용) 함수
ex. 무기Class : 데미지 변수, 강화 함수 / 캐릭터Class : 무기Class, 캐릭터 공격력
-> 무기Class에서 강화 함수를 통해 데미지 변수를 증가시키면 캐릭터Class의 공격력이 증가하는 것이 아닌
-> 캐릭터Class가 가지고 있는 무기Class의 강화 함수(public함수)를 호출시켜 데미지 변수를 증가시킨다.
즉, 객체의 독립성을 위해 A객체가 수정되거나 변경될 때 다른 객체들에 영향이 없도록 하는 것

3. 상속성(inheritance) : 이전에 만들어진 class의 기능을 가져와 재활용한다.
ex. 사람Class를 만들고 후에 학생, 직장인 Class를 만들려 할 때 사람이라는 공통분모를 활용해 만들어둔 사람Class에서 필요한 부분을 사용
이러한 특징을 상속성이라한다.

4. 다형성(polymorphism) : 약속된 부분만 유지한다면 얼마든지 접근방식을 바꿀 수 있다. (오버로딩,오버라이딩,가상함수)
ex. 사람Class를 만들고 후에 학생, 직장인 Class를 만들려 할 때 사람이라는 공통분모를 활용해 만들어둔 사람Class에서 필요한 부분을 사용
-> 하는 일이 다르기 때문에 work라는 함수를 사람Class에 만들어놓기만 하고 아무런 동작을 집어넣지 않음
-> 사람Class를 상속받은 후 학생, 직장인에 맞는 work함수를 작성

*장점*
1. 객체지향 특징으로 코드 재사용이 가능하다.
2. 절치지향과 달리 독립된 객체로 이루어져 있기 때문에 유지보수가 용이하다. -> 문제가 되는 부분만 찾아 고치면 된다.

*단점* 
1. 캡슐화 격리 구조 때문에 절차형 프로그래밍에 비해 속도가 느리다.
-> 절차지향의 입장에서 봤을 때 객체지향과는 성격이 맞지 않기 때문에 상대적으로 느릴 수도 있는 것이지 단점이라기엔 애매하다.
2. 모든 객체의 역할과 기능을 이해해야하므로 프로그래밍에 많은 시간이 소요된다.



