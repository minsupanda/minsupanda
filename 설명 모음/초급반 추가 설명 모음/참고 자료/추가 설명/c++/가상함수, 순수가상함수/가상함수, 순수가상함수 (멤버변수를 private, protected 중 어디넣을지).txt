https://coding-factory.tistory.com/699
http://www.tcpschool.com/cpp/cpp_polymorphism_virtual (가상함수 테이블 : 가상함수 호출 원리?방식?)
https://forswdev.tistory.com/entry/C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%83%81%EC%86%8DInheritance%EA%B3%BC-%EB%8B%A4%ED%98%95%EC%84%B1polymorphism
[가상함수]
- UpCasting했을 때, 오버라이딩 된 자식Class의 함수를 사용해도 부모 Class 함수가 호출되었음
-> 이러한 문제를 해결하기 위해 가상함수를 사용하는 것
- virutal을 사용하면 이 함수가 오버라이딩 되어있는지 파악한다
*** 기본적으로 가상함수를 사용했다 -> UpCasting 했다 *** 


<예제코드>
- 자식 class에서 오버라이딩 된 함수들은 앞에 virtual을 붙여도 되고, 안 붙여도 된다 (취향, 개발환경에 따라 다름)
 or 뒤에 override를 붙이기도 한다

- 오버라이딩할 함수가 부모와 자식간의 함수 이름이 동일하지 않다면 그 함수를 호출할 때 부모함수가 호출된다.
-> 이를 해결하려면 아예 자식 클래스의 함수가 호출되게 클래스를 변수로 선언하고 다시 함수를 호출해야 하는데,
이러한 과정을 줄이기 위해 오러라이딩과 가상함수를 사용하는 것이다
=> 즉, 관리 용이함

- 소멸자에도 virtual을 붙이는 이유
 : virtual이 없으면 부모 함수만 호출되 듯, 똑같이 부모 소멸자만 호출이 되기 때문이다.


--------------------------------

[순수가상함수] ********* 많이 활용 *********

1. 부모 Class가 자식 Class의 뼈대를 구축하는 역할을 할 때 (ex. 롤에서 '챔피언'이라는 Class)
부모 Class의 생성을 막기 위함

2. 자식 Class에서 오버라이딩이 제대로 되지 않아 자식 Class의 함수가 호출되어야 하는데 부모 Class가 호출되는 경우
를 막기 위해

=> 순수가상함수는 말그대로 속이 비어있는 함수, 그렇기 때문에 순수가상함수가 선언된 Class는 변수로 선언되지 못하는 것
=> 순수가상함수를 선언하면 자식 Class는 반드시 그 함수를 오버라이딩하는 것이 필수이기 때문에 오류를 띄워 문제를 방지하는 것


<예제코드>
- 만약 순수가상함수로만 이루어진 Class라면 cpp파일을 없애도 무관하지만 후에 확장성을 고려해 놔두는게 낫다.

- 밑의 예제처럼 자식 Class에서 모두 공통적으로 이루어질 코드가 생길 수도 있기 때문(이동, 공격 등)

<다중 상속 문제>
-A Class가 두번 호출된다는 것인데, 이때 A Class에 virtual 붙여 상속한다면 이러한 문제를 해결할 수 있다

-----------------------------------
[예외]

Q : 롤에서 챔피언이라는 Class를 만들 때 기본적으로 공통되는 정보(HP, ATTACK, SPELL 등)는 private, protected 중 어디 넣냐?

A : 취향차이 










상속


* 추상 클래스(abstract)
- 이 클래스는 반드시 어딘가에서 상속받아서 쓰일거라고 선언하는 것


* 순수 가상 함수
- 이 함수는 반드시 어딘가에서 오버라이딩 되서 쓰이는 것
- 호출될 때마다 동작이 다르게 되도록 설정하는 것


* 가상 함수
- 이 함수가 어딘가에서 오버라이딩 될 수도 있고, 안 될 수도 있는 것
- 기본적으로는 이 함수의 원형으로 사용되는데, 오버라이딩 되어 있는 경우에서 다르게 동작 되도록 설정하는 것


- 그러면 순수 가상 함수와 가상 함수 중 어떻게 사용할 지 결정하는 거는?
 -> 원형으로도 동작이 되냐 안 되냐? 한 번이라도 원형으로 동작이 된다면 가상함수로, 아니면 순수 가상함수로?

- 추상 클래스는 반드시 함수가 전부다 순수 가상 함수로 이루어 져있나?

