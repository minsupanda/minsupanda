#include<stdio.h>


int Num1;

void main()
{
	char str[256] = "안녕하세요";
	int Num2 = 20;
}

// Code영역(ROM : 읽기 전용 메모리) : 우리가 소스파일에 쓰는 모든 코드들은 Code영역에 저장된다 -> 요리에서 레시피 같은 개념, 계획서
// -> 변할 수 없다.(프로그램을 실행했을 때의 기준) -> 우리가 지금껏 적은 코드들은 프로그램 실행시 변동이 불가능했음
// 
// Date영역 : 전역변수의 프로그램 실행시 데이터공간이 만들이저고 종료 시 날라간다는 특징은 Date영역의 특징이다
// 우리가 소스파일에 전역변수를 선언하면 Code영역에 적히게 되고 운영체제는 Code영역에 적힌 모든 코드들을 읽으면서 전역변수를 만나면
// 전역변수를 Date영역에 저장한다.
// 
// Stack영역 : 지역변수는 스코프()의 범위에 따라 지역이 결정되고 그 범위를 시작하면 만들이지고 그 범위가 종료되는 날라가는 특징으로 Stack영역의 특징이다
// Date와 동일하게 운영체제가 Code영역을 읽으면서 지역변수를 만나면 Stack영역에 저장한다.
//
//운영체제는 컴파일하기전에 소스파일에 적힌 코드를 읽고 이 파일이 얼마나 저장공간이 필요한지 알고 미리 준비를 한다.
//지금껏 우리가 적은 코드들은 프로그램을 실행했을 때는 바꿀 수 없기 때문에 미리 운영체제가 저장공간을 준비할 수 있고 이를 '정적할당'이라고 한다

//정적할당 : 컴파일시 할당될 메모리 크기가 결정되며 정확히는 운영체제가 PE파일이라고 만들게 되는데 여기서 미리 이 프로그램은 크기가 얼마나 필요하며
//이러이러한 프로그램이라는 파일을 만들고 여기서 결정된 메모리의 크기를 컴파일 시 이 메모리의 크기만큼 공간을 할당한다.(각 영역에 각 변수에 맞게 할당)
//즉, Stack, Date영역에 변수로 할당되는 메모리

//정적할당은 미리 준비해서 사용하는 만큼 빠른 속도로 처리할 수 있지만, 미리 준비된 만큼의 크기만 사용할 수 있다.


//하지만 프로그램 실행 중에 바꾸고 싶음

// Heap영역 : 동적할당 저장공간으로 이 영역의 메모리 크기는 실행 중 그때그때 결정된다.
// 유동적으로 사용할 수 있지만, 미리 준비할 수 없으므로 처리속도가 느리고 변동되는 메모리는 우리가 직접 관리해야한다.
// 즉, 동적할당은 컴파일 시점에서 데이터의 크기를 결정할 수 없는 경우에 사용할 수 있다.

//정적, 동적할당 두가지 모두 사용할 수 있는 언어는 c, c++로 둘 다 사용할 수 있는 만큼 최적화에 유용하므로 게임을 만들 때 주력언어가 되는 것이다.


//근데 왜 정적, 동적 둘다 사용하는게 최적화에 유리한것인지??????????????
// 동적을 사용하면서 직접 메모리를 관리하면 잉여메모리를 막을 수 있기 때문이다.
//그러니까 c,c++은 내가 원하는 시점에서 메모리를 만들고 해제하는 것이 가능하므로 더 좋다는 것
//다른 언어는 내가 정적, 동적할당을 사용할 권한이 없이 오로지 동적만 사용하게 된다.
