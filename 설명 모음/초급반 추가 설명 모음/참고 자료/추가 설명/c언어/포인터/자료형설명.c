#include<stdio.h>

void main()
{

	int Num = 10, *pNum;
	char Ch = 'a', * pCh;

	// cpu 연산처리장치
	// 레지스터 연산처리 임시메모리
	//ALU == 손 : CPU와 레지스터 왔다갔다 하면서 메모리 전달 --> 운영체제의 크기에 따라 가지고 갈 수 있는 양이 달라짐
	// 32bit보다 64bit가 더 연산처리가 빠른 이유가 이것
	// 더 많은 정보를 한번에 많이 처리할 수 있다


	﻿//char형은 왜 음수범위를 포함하지 않는가?
	//영어,숫자 1바이트
	//2바이트
	//인코딩 : 문자처리방식 영어,한글,중국어,일본어
	// 처음에는 영어수자라서 다른언어를 급하게 사용하기 위해 만든게 멀티바이트
	// 하지만 다른언어는 2byte 5만얼마로 처리하고 영어숫자는 1byte로 처리해서 컴퓨터 입장에서는 byte마다 끊어 읽어야 하기 때문에 고되다
	// 그래서 이런 문제를 해결하기 위해 나온게 유니코드
	//유니코드 : 2바이트 : UTF-8
	//멀티바이트 : 2바이트
	// char형은 멀티바이트?


	//자료형의 의미
	// 사용하는 자료의 2진수값을 해당 자료형에 맞게 번역한다는 것??


	//int형이 4byte인 이유
	//-21~+21까지 표현하기 위한 메모리의 크기는 2진수가 32개있으면 되기 때문
	// 즉, -21~+21 수의 범위를 표현하기 위해서는 1개당 1bit이므로 총 32bit로 4byte가 된다.
	//--> 2의 31제곱이 4,294,967,296이기 때문에 4byte
		//가장 앞자리는 부호비트 0이면 양수 1이면 음수 -> 그럼 2의 30제곱으로 딱 절반 21억 -> 양수 21억 음수 21억 합해서 42억


	//char가 1byte인 이유
	// 문자열을 표시하려면 아스키코드표상으로 아무리 커봤자 127을 안넘어감
	// 1byte == 8bit이고 2진수 8자리로 표현이 가능하다
	// 2의 7제곱이 256으로 제일 맞는 크기이기 때문이다.
	//1byte : 0 ~ 255 : 256개 -128 ~ 127 


	// 포인터 자료형의 크기가 4인 이유
	// 32bit 운영체제 메모리 주소는 1bit로 32자리이다
	// 32bit 운영체제 기준으로는 8bit == 1byte이므로 총 4byte짜리 주소가 있는 것
	// 4byte는 2진수가 32개 모인것으로 총합 2의 31제곱만큼의 값만 필요하면 된다
	// 그렇기 때문에 포인터변수의 자료형의 크기는 4byte가 되는 것이다
	//즉, 운영체제가 64bit로 바뀌면 총 8byte짜리 주소가 있는 것으로 포인터 변수의 자료형의 크기도 8byte로 바뀐다.
	//워드(word)란 CPU가 한 번에 처리할 수 있는 데이터의 크기입니다.
	//1바이트는 8비트이므로 32비트 시스템에서는 32비트 / 8비트 = 4, 즉 4바이트가 1워드(word)로 처리됩니다.	
	//64비트 시스템에서는 64비트 / 8비트 = 8, 즉 8바이트가 1워드(word)로 처리됩니다.

	pNum = &Num;
	pCh = &Ch;

	printf("char 자료형의 크기 = %d\n", sizeof(Ch));
	printf("int 자료형의 크기 = %d\n", sizeof(Num));
	printf("char 자료형의 크기 = %d\n", sizeof(pCh));
	printf("int 자료형의 크기 = %d\n", sizeof(pNum));
}