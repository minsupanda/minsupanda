자료구조의 종류

선형적 자료구조
Array,DynamicArray,Stack,Queue,LinkedList

비선형적 자료구조
Tree,BinarySaerchTree,B-Tree,AVL-Tree,RedBlackTree,Heap

자가균형트리
AVL-Tree,RedBlackTree

코드비용계산
BigO표기법 : 일반 상수 계산은 무시
↑1
│log n
│n
│n log n
│n^2
│n^3

시간복잡도 : 데이터양에 따른 처리 횟수
공간복잡도 : 데이터양에 따른 필요 메모리수

Array
배열이름은 시작주소를 저장한다.
배열의 메모리주소는 연속성을 가진다.
배열 인덱스번호는 0부터 시작한다.
배열내에 특정위치의 변수에 접근하는방법은 시작주소에 해당 인덱스를 더해서 접근한다.
ex)
int Num[5]
Num : 100
Num[0]	Num[1]	Num[2]	Num[3]	Num[4]
100~103	104~107	108~111	112~115	116~119

시간복잡도 : O(1)
공간복잡도 : X

DynamicArray(가변배열)
int Num[5]
Num : 100
Num[0]		Num[1]		Num[2]		Num[3]		Num[4]
100~103		104~107		108~111		112~115		116~119

int NewNum[6]
NewNum: 200
NewNum[0]	NewNum[1]	NewNum[2]	NewNum[3]	NewNum[4]	NewNum[5]
200~203		204~207		208~211		212~215		216~219		220~223

시간복잡도 : O(1)
공간복잡도 : O(n)


[자기참조구조체]
구조체의 맴버변수에 자신과 동일한 구조체변수의 주소를 저장하여 참조하는 형태

데이터에 접근하려면 가정 처음 head부터 시작해서 찾아가기 때문에 시간복잡도는 n이된다.


시간복잡도 : O(n)
공간복잡도 : O(1)

추가하려는 데이터가 있으면 해당 데이터만큼의 공간만 증설하면 되기 때문에 공간복잡도는 1이 된다.

[Stack]
후입선출에 의해 순서대로 사용하는 자료구조

자기참조구조체와 반대로 Top이라는 포인터가 만들어지고 Top은 항상 가장 마지막에 저장된 데이터를 가리케기 된다.
항상 최근 데이터를 가리키고 최근 데이터가 이전 데이터를 가리키는 형식이기 때문에 시간복잡도는 1이 된다.
또한 추가할 데이터만큼만 증설하면 되기 때문에 공간복잡도도 1이 된다.

데이터 영역중에 지역변수를 담당하는 Stack영역도 이런 자료구조 Stack에서 파생된 것이다.

시간복잡도 : O(1)
공간복잡도 : O(1)

[Queue]
선입선출에 의해 순서대로 사용하는 자료구조

Stack과는 반대로 선입선출으로 입구가 두개다. 입력을 담담하는 enqueue와 출력을 담당하는 dequeue
데이터를 저장하면 가장 처음 저장된 데이터를 가리키는 Front와 가장 마지막에 저장된 데이터를 가리키는 Rear이 생긴다.
가장 처음 NULL값이 저장 -> 데이터를 만들고 Link1에 NULL저장하면 Front,Rear는 1을 가리킨다
-> 데이터를 새로 만들고 Link2에 NULL저장하면 Front는 여전히 1, Rear은 2를 가리킨다.
데이터를 해제할때는 Front가 가리키는 데이터를 출력시키고 해제시키고 다음 Link를 가리키면 된다
(이때 데이터를 마지막까지 해체했을 때 Rear도 NULL로 초기화시켜줘야한다)

시간복잡도 : O(1)
공간복잡도 : O(1)

-------------------------------------
자기참조구조체를 사용하는 자료구조는 필요한 만큼만 데이터를 만들면 되기 때문에 공간복잡도는 1 이된다.
Stack, Queue는 시간,공간 복잡도가 좋지만 가리키는 데이터만 사용 가능하다는 단점이 있다.
자기참조구조체는 내가 원하는 데이터에 접근이 가능하다는 장점이 있지만 Link를 타고타고 들어가야하기 때문에 시간복잡도가 n이 된다는 단점이 있다
그러므로 상황에 맞게 적절한 자료구조를 사용해서 최적화를 해야한다.
간단한 예를 들면 키오스크는 선입선출 방식으로 Queue를 사용하는 것
----------------------------------------


[Linked List]

시간복잡도 : O(n)
공간복잡도 : O(1)

삽입,추가,수정,삭제,검색

자기참조구조체 예제코드와 거의 비슷하다.
(자기참조구조체는 가변배열과 대립되는 개념으로 시간이 중요하면 가변배열, 공간이 중요하면 자기참조구조체를 사용)



[BinarySearchTree]

시간복잡도 : O(log n)
공간복잡도 : O(1)

삽입,삭제,검색

데이터수	접근횟수	이동횟수
1	1	0
2~3	2	1	log2(2 ~ 3)  :  1
4~7	3	2	log2(4~7) :  2
8~15	4	3	log2(8~15) : 3
16~31	5	4	log2(n) : 3
32~63	6	5	...
64~127	7	6	...

특징
1.중복데이터 저장불가(key 값 기준)
->BinarySerachTree는 key값, value값(key값을 제외한 값)이 있는데 대소관계비교를 위한 key값이 중복되면 안된다는 뜻이다.
-> 즉, 피피티 그림을 보면 숫자가 홈페이지의 아이디와 같은 개념으로 중복되면 안되는 key값이고 그안에 들은 사람의 정보
들은 value값으로 중복되는 되는 값들이다.
2.데이터의 저장순서 식별불가
3.저장데이터가 많을수록 효율성이 올라감
4.마지막에 저장된 값을 알수없다.
--------------------------------------
코드비용만보면 Tree가 더 좋을 것 같지만 오히려 데이터 수가 적을 때는
BinarySerachTree는 대소관계비교를 위한 처리도 필요하기 때문에 Linked_List가 더 좋을 수 있다.(Big-O표기법 참고)
--------------------------------------


[AVL Tree]

시간복잡도 : O(log n)
공간복잡도 : O(1)

특징
1. BinarySearchTree는 데이터가 한쪽으로 몰리면 효율성이 매우 떨어지게 된다. 이러한 단점을 보완한 것이다
-> 자동으로 데이터를 균형있게 재배치 시켜준다
-> 이런 재배치 과정을 기준으로 AVL, RedBlack Tree가 나뉜다.
2. 이런 단점보완을 제외한 나머지 부분은 BinarSearchTree와 동일하다

-------------------------------------------------
<C++자료구조>
STL(Standard Template Library)
Algorighm,Maths(수학),Container(자료구조),Functional(함수)

Container : 자료구조 집합 자료형

Stack, Queue, List( = c언어 Linkde List), Vector( = dynamic Array가변배열), Map( = RedBlackTree)
->c언어에서는 이러한 기능을 가진 라이브러리가 공식적으로 제공되지 않음.

배열 : 모든 변수의 메모리 주소는 연속된다.
-> 배열의 이름은 시작주소를 저장하고 있으면 특정 원소 접근 시 시작 주소에 + 연산을 하여 접근한다.

list
장점 : 데이터 저장 삭제가 자유롭다.
단점 : 데이터 접근속도가 느리다.

vector(가변배열)
장점 : 데이터의 접근속도가 빠르다.
단점 : 데이터의 저장 삭제가 비효율적이다.





