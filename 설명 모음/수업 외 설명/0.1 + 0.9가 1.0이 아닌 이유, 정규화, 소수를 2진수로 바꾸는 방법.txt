* 모든 자료형의 범위(e는 자료형의 비트 크기) : 2^(e-1) ~ 2^(e-1) - 1 

<character>
- 8bit = 1byte
- (부호비트) () () () () () () () => 부호비트 : 0(양수), 1(음수)
- -128 ~ 127

<2진수로 바꾸는 방법>
ex) 32 => 10 0000 ( /2를 하면서 나머지 값을 거꾸로 읽으면 된다 )
ex) 0.625 => 0.101 ( *2를 하면서 위에서 부터 읽으면 된다)

<0.101를 다시 10진수로 바꾸는 방법>
- ***그림판 보기***

<32.625를 2진수로 바꾸는 방법>
- 32 / 0.625를 2진수로 바꾼 값을 합친다 => 0010 0000.101
- 이 값을 정규화 시켜야 한다

<정규화>
- 1.xxxxxx가 되도록 변경하는 것
ex) 100000.101 =>   1.00000101 X 2^5
ex) 0.101 => 1.01 X 2^-1


<flaot 기호부(1) 지수부(8) 가수부(23)>
- Bias : 2^(e-1) - 1
- 지수부 : 2^(8-1) - 1 + 지수(5) => 132 => 10000100
- 가수부 : 1.00000101 => 000001010000000~
=> 0 100000100 00000101000~ 이런식으로 들어가게 된다

<double 기호부(1) 지수부(11) 가수부(나머지(64-12))>
<signed int 기호(1) 정수(31)>
- unsigned int 일 때는 정수(32)가 된다

---------------------------------------------

<0.1 + 0.9 = 1.0이 아닌 이유>
- 0.1과 0.9는 컴퓨터가 정확히 그 값이 아니라 이에 근사한 다른 값으로 인식하고 있기 때문이다.
- 이유는 0.1과 0.9를 2진수로 바꾸게 되면 무한히 반복되게 되고, 가수부는 23자리가 한계이기 때문에 중간에 끊긴 다른 값이 들어간 상태로 2진수로 변환되기 때문이다

